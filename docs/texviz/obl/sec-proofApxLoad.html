<!DOCTYPE html>
<html lang="en">
<head>
<script>
  MathJax = { 
    tex: {
		    inlineMath: [['$','$'], ['\\(','\\)']]
	} }
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<meta name="generator" content="plasTeX" />
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Proof of GetApproxLoad correctness assuming exact Laplacian solver</title>
<link rel="next" href="sec-lsolvex.html" title="Proof of correctness" />
<link rel="prev" href="sec-proofWidthBound.html" title="Bounding the Width" />
<link rel="up" href="index.html" title="Electrical Flows for Polylogarithmic Competitive Oblivious Routing" />
<link rel="stylesheet" href="styles/theme-white.css" />
<link rel="stylesheet" href="styles/amsthm.css" />
<link rel="stylesheet" href="styles/showmore.css" />
<link rel="stylesheet" href="styles/extra_styles.css" />
</head>

<body>
<header>
<svg  id="toc-toggle" class="icon icon-list-numbered "><use xlink:href="symbol-defs.svg#icon-list-numbered"></use></svg>
<h1 id="doc_title"><a href="index.html">Electrical Flows for Polylogarithmic Competitive Oblivious Routing</a></h1>
</header>

<div class="wrapper">
<nav class="toc">
<ul class="sub-toc-0">
<li class="">
  <a href="sec-proofOracleReturn.html"><span class="toc_ref">1</span> <span class="toc_entry">Bound on Average Loads</span></a>
 </li>
<li class="">
  <a href="sec-proofWidthBound.html"><span class="toc_ref">2</span> <span class="toc_entry">Bounding the Width</span></a>
 </li>
<li class=" active current">
  <a href="sec-proofApxLoad.html"><span class="toc_ref">3</span> <span class="toc_entry">Proof of GetApproxLoad correctness assuming exact Laplacian solver</span></a>
 </li>
<li class="">
  <a href="sec-lsolvex.html"><span class="toc_ref">4</span> <span class="toc_entry">Proof of correctness</span></a>
 </li>
<li class="">
  <a href="sec-apxlsolve.html"><span class="toc_ref">5</span> <span class="toc_entry">Algorithm using approximate Laplacian solvers</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="sec-apxlsolve.html#sec:changes"><span class="toc_ref">5.1</span> <span class="toc_entry">Changes in the algorithm</span></a>
 </li>

  </ul>
 </li>
<li ><a href="dep_graph_document.html">Dependency graph</a></li>
</ul>
</nav>

<div class="content">
<div class="content-wrapper">


<div class="main-text">
<h1 id="sec:proofApxLoad">3 Proof of GetApproxLoad correctness assuming exact Laplacian solver</h1>

<p><div class="lemma_thmwrapper" id="thm:SketchApprox">
  <div class="lemma_thmheading">
    <span class="lemma_thmcaption">
    Lemma
    </span>
    <span class="lemma_thmlabel">6</span>
    <div class="thm_icons">
    <a class="icon proof" href="sec-proofApxLoad.html#thm:SketchApprox">#</a>

  </div>
  </div>
  <div class="lemma_thmcontent">
  <p> Given \(m \in \mathbb {Z}_{\ge 1}\), \(\delta \in (0,1)\), and \(\epsilon \in (0, 1)\), there is a sketch matrix \(C = \text{SketchMatrix}(m, \delta , \epsilon ) \in \mathbb {R}^{\ell \times m}\) and an algorithm \(\text{RecoverNorm}(s)\) for \(s \in \mathbb {R}^{\ell }\) such that the following properties hold: </p>
<ul class="itemize">
  <li><p>(Approximation) For any \(v \in \mathbb {R}^m\), with probability at least \(1 - \delta \) over the randomness of SketchMatrix, the value of \(r = \text{RecoverNorm}(Cv)\) is </p>
<div class="displaymath" id="a0000000014">
  \[  (1-\epsilon ) \| v\| _1 \le r \le (1+\epsilon ) \| v\| _1  \]
</div>
</li>
  <li><p>\(\ell = c/\epsilon ^2 \cdot \log (1/\delta )\) for some constant \(c{\gt}1\) </p>
</li>
  <li><p>(running time) SketchMatrix and RecoverNorm take time \(O(\ell m)\) and \(poly(\ell )\) respectively. </p>
</li>
</ul>

  </div>
</div> </p>
<p>We use the guarantees of SketchMatrix and RecoverNorm provided by <a href="sec-proofApxLoad.html#thm:SketchApprox">Lemma 6</a> to prove the following lemma. </p>
<p>The third lemma shows that the error introduced by using a matrix sketch in \(\text{GetApproxLoad}\) is not too large, i.e., that \(\text{GetApproxLoad}\) approximates the true loads well. For simplicity, we assume that the Laplacian solver used in \(\text{GetApproxLoad}\) is exact and runs in time \(\widetilde{O}(m)\). The analysis with an approximate solver is given in <a href="sec-apxlsolve.html">Chapter 5</a>. </p>
<p><div class="lemma_thmwrapper" id="lem:ApxLoad">
  <div class="lemma_thmheading">
    <span class="lemma_thmcaption">
    Lemma
    </span>
    <span class="lemma_thmlabel">7</span>
    <div class="thm_icons">
    <a class="icon proof" href="sec-proofApxLoad.html#lem:ApxLoad">#</a>
    <a class="icon proof" href="sec-proofApxLoad.html#a0000000015"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>

  </div>
  </div>
  <div class="lemma_thmcontent">
  <p> For any approximation factor \(0 {\lt} \epsilon {\lt} 1\), and any weighted graph \((G,w)\), let \(\textrm{load}_w= \left( w_e \sum _f |b_e L^{\dagger }b_f^{\mkern -1.5mu\mathsf{T}}|\right)_{e \in E} \) be the true loads, and \(\textrm{aload}_w= \text{GetApproxLoad}(G, w, \epsilon )\) be the approximate loads computed by the algorithm. Then with probability \(\ge 1 - \frac{1}{poly(n)}\), </p>
<div class="displaymath" id="a0000000016">
  \[  (1 - \epsilon ) \cdot \textrm{load}_w(e) \le \textrm{aload}_w(e) \le (1 + \epsilon ) \cdot \textrm{load}_w(e) \qquad \text{for all $e \in E$}  \]
</div>

  </div>
</div> </p>
<div class="proof_wrapper" id="a0000000015">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof
    </span>
    <span class="expand-proof">▼</span>
  </div>
  <div class="proof_content">
  <p>Note that \(\text{GetApproxLoad}\) sends \((L^{\dagger }B^{\mkern -1.5mu\mathsf{T}}C^{\mkern -1.5mu\mathsf{T}})^{\mkern -1.5mu\mathsf{T}}b_e\) to \(\text{RecoverNorm}\). This simplifies to \(CBL^{\dagger }b_e\). We get from the approximation guarantee of Theorem <a href="sec-proofApxLoad.html#thm:SketchApprox">6</a> that </p>
<div class="displaymath" id="a0000000017">
  \[  (1-\epsilon )\cdot \|  BL^{\dagger }b_e \| _1 \le \text{RecoverNorm}(BL^{\dagger }b_e) \le (1+\epsilon )\cdot \|  BL^{\dagger }b_e \| _1  \]
</div>
<p> Since \(\textrm{load}_w(e) = w_e \cdot \| BL^{\dagger }b_e\| _1\), multiplying the above inequality by \(w_e\), we get </p>
<div class="displaymath" id="a0000000018">
  \[  (1-\epsilon )\cdot \textrm{load}_w(e) \le \text{GetApproxLoad}(G, w) \le (1+\epsilon )\cdot \textrm{load}_w(e)  \]
</div>
<p> as required. </p>

  </div>
</div>

</div> <!--main-text -->
</div> <!-- content-wrapper -->
</div> <!-- content -->
</div> <!-- wrapper -->

<nav class="prev_up_next">
  <svg  id="showmore-minus" class="icon icon-eye-minus showmore"><use xlink:href="symbol-defs.svg#icon-eye-minus"></use></svg>

  <svg  id="showmore-plus" class="icon icon-eye-plus showmore"><use xlink:href="symbol-defs.svg#icon-eye-plus"></use></svg>

  <a href="sec-proofWidthBound.html" title="Bounding the Width"><svg  class="icon icon-arrow-left "><use xlink:href="symbol-defs.svg#icon-arrow-left"></use></svg>
</a>
  <a href="index.html" title="Electrical Flows for Polylogarithmic Competitive Oblivious Routing"><svg  class="icon icon-arrow-up "><use xlink:href="symbol-defs.svg#icon-arrow-up"></use></svg>
</a>
  <a href="sec-lsolvex.html" title="Proof of correctness"><svg  class="icon icon-arrow-right "><use xlink:href="symbol-defs.svg#icon-arrow-right"></use></svg>
</a>
</nav>

<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/plastex.js"></script>
<script type="text/javascript" src="js/svgxuse.js"></script>
<script type="text/javascript" src="js/js.cookie.min.js"></script>
<script type="text/javascript" src="js/showmore.js"></script>
</body>
</html>